Ya podemos testear que un componente tenga una apariencia o condición inicial.

Ahora lo siguiente naturalmente es, desde el test, interactuar con el componente y comprobar que lo que sea que deba pasar al ser clickeado, efectivamente ocurra.

En nuestro caso lo que tenemos que hacer es verificar que cuando se clickee el botón, el color cambie.

La base será la misma, buscamos de la misma manera que antes el botón, por role y name; pero luego necesitamos poder clickearlo de alguna manera.
Para ello, importamos fireEvent, el cual es un objeto que contiene diferentes métodos que corresponden a diferentes acciones de usuario, como por ejemplo el método click, que emulará un click en el elemento que le pasemos como argumento.

Como siempre, el test al principio fallará, pero en cuanto codeemos lo que necesitamos, pasará sin problemas.

Finalmente podemos también incluir en el mismo test que verifique que el texto también cambie.

En sí, podemos incluir todos los expect que necesitemos en un mismo test, siempre y cuando se mantenga dentro de lo que su nombre indique. Cuando un expect falle por no cumplirse la condición, dejará de correr y no avanzará a los siguientes expect.

Desde el punto de vista de unit test puro, se recomienda que haya un test por CADA expect.
Desde el punto de vista de functional testing, ésto no tiene sentido y tranquilamente pueden ir juntos. Esto es porque functional testing se concentra, como dijimos anteriormente, en testear comportamiento basado en cómo el usuario interactúa con nuestro sitio.

Así, aprovechamos en el mismo test el elemento, y usamos el matcher toHaveTextContent para verificar que el contenido del texto del botón sea el que esperamos.

Los matchers, tal como mencionábamos anteriormente, los tenemos todos acá, en la documentación de jest-dom:
https://www.npmjs.com/package/@testing-library/jest-dom